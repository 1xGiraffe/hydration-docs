"use strict";(self.webpackChunkhydra_dx_docs=self.webpackChunkhydra_dx_docs||[]).push([[454],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return f}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),f=a,h=p["".concat(l,".").concat(f)]||p[f]||d[f]||r;return n?i.createElement(h,o(o({ref:t},c),{},{components:n})):i.createElement(h,o({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9192:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return p}});var i=n(3117),a=n(102),r=(n(7294),n(3905)),o=["components"],s={id:"dev_pallet_xyk",title:"XYK Pallet",slug:"/xyk"},l=void 0,u={unversionedId:"dev_pallet_xyk",id:"dev_pallet_xyk",title:"XYK Pallet",description:"Overview",source:"@site/docs/dev_pallet_xyk.md",sourceDirName:".",slug:"/xyk",permalink:"/cn/xyk",editUrl:"https://github.com/galacticcouncil/HydraDX-docs/edit/main/docs/dev_pallet_xyk.md",tags:[],version:"current",frontMatter:{id:"dev_pallet_xyk",title:"XYK Pallet",slug:"/xyk"},sidebar:"sidebar",previous:{title:"Asset Registry",permalink:"/cn/registry"},next:{title:"HDX Pallet",permalink:"/cn/dev_pallet_hdx"}},c=[{value:"Overview",id:"overview",children:[],level:3},{value:"Config",id:"config",children:[],level:3},{value:"Storage",id:"storage",children:[],level:3},{value:"Extrinsics",id:"extrinsics",children:[{value:"create_pool",id:"create_pool",children:[],level:4},{value:"add_liquidity",id:"add_liquidity",children:[],level:4},{value:"remove_liquidity",id:"remove_liquidity",children:[],level:4},{value:"buy / sell",id:"buy--sell",children:[],level:4}],level:3}],d={toc:c};function p(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Uniswap AMM model implementation."),(0,r.kt)("p",null,"This pallet also implements the AMM trait which makes it possible to plug it into exchange pallet."),(0,r.kt)("h3",{id:"config"},"Config"),(0,r.kt)("p",null,"Config is pretty straight-forward."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Config: frame_system::Config + pallet_asset_registry::Config {\n    type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;\n\n    /// Share token support\n    type AssetPairAccountId: AssetPairAccountIdFor<AssetId, Self::AccountId>;\n\n    /// Multi currency for transfer of currencies\n    type Currency: MultiCurrencyExtended<Self::AccountId, CurrencyId = AssetId, Balance = Balance, Amount = Amount>;\n\n    /// Native Asset Id\n    type NativeAssetId: Get<AssetId>;    \n\n    /// Weight information for the extrinsics.\n    type WeightInfo: WeightInfo;\n\n    /// Trading fee rate\n    type GetExchangeFee: Get<fee::Fee>;\n}\n")),(0,r.kt)("h3",{id:"storage"},"Storage"),(0,r.kt)("p",null,"A pool is created for each asset pair. Information about the existing pools is kept in the following storage structures:"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"ShareToken")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub type ShareToken<T: Config> = StorageMap<_, Blake2_128Concat, \n    T::AccountId, \n    AssetId, \n    ValueQuery>;\n")),(0,r.kt)("p",null,"Mapping between a pool account and an asset id obtained from the registry."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"PoolAssets")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub type PoolAssets<T: Config> = StorageMap<_, \n    Blake2_128Concat, \n    T::AccountId, \n    (AssetId, AssetId), \n    ValueQuery>;\n")),(0,r.kt)("p",null,"Mapping between a pool account and a tuple of assets in this pool. This is useful only when listing existing pools and their assets (eg. for FE)."),(0,r.kt)("h3",{id:"extrinsics"},"Extrinsics"),(0,r.kt)("p",null,"This pallet has the following extrinsics:"),(0,r.kt)("h4",{id:"create_pool"},"create_pool"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[pallet::weight(<T as Config>::WeightInfo::create_pool())]\n#[transactional]\npub fn create_pool(\n    origin: OriginFor<T>,\n    asset_a: AssetId,\n    asset_b: AssetId,\n    amount: Balance,\n    initial_price: Price,\n) -> DispatchResultWithPostInfo {}\n")),(0,r.kt)("p",null,"As the name suggests, this creates a pool between asset A and asset B (if such pool does not already exist) with initial liquidity determined by the amount and initial price.\nIt generates a name for this asset pair and asks the registry to return an id for the name (either assigning a new one or reusing a previously assigned name, if such pool existed)."),(0,r.kt)("p",null,"It also constructs a pool account for this pair and stores the mapping in storage under ShareToken as described above. "),(0,r.kt)("p",null,'You may ask "How do we know the account if we add liquidity for example"? Constructing the pool account id is deterministic, so adding liquidity into the pool of  asset A and B would generate the same account id. This is demonstrated in the following example:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn from_assets(asset_a: AssetId, asset_b: AssetId) -> T::AccountId {\n    let mut buf = Vec::new();\n    buf.extend_from_slice(b"hydradx");\n    if asset_a < asset_b {\n        buf.extend_from_slice(&asset_a.to_le_bytes());\n        buf.extend_from_slice(&asset_b.to_le_bytes());\n    } else {\n        buf.extend_from_slice(&asset_b.to_le_bytes());\n        buf.extend_from_slice(&asset_a.to_le_bytes());\n    }\n    T::AccountId::unchecked_from(T::Hashing::hash(&buf[..]))\n}\n')),(0,r.kt)("h4",{id:"add_liquidity"},"add_liquidity"),(0,r.kt)("h4",{id:"remove_liquidity"},"remove_liquidity"),(0,r.kt)("p",null,"Add and remove liquidity are pretty straight-forward and easy to understand by checking the implementation."),(0,r.kt)("h4",{id:"buy--sell"},"buy / sell"),(0,r.kt)("p",null,"Probably the most interesting part of the pallet. Sell and buy are very similar however they differ in few minor details - what and how is checked\nwhen resolving the transaction (mostly multiple limits)."),(0,r.kt)("p",null,"Sell:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[pallet::weight(<T as Config>::WeightInfo::sell())]\npub fn sell(\n    origin: OriginFor<T>,\n    asset_in: AssetId,\n    asset_out: AssetId,\n    amount: Balance,\n    min_limit: Balance,\n    discount: bool,\n) -> DispatchResultWithPostInfo {\n    let who = ensure_signed(origin)?;\n\n    <Self as AMM<_, _, _, _>>::sell(&who, AssetPair { asset_in, asset_out }, amount, min_limit, discount)?;\n\n    Ok(().into())\n}\n")),(0,r.kt)("p",null,"In the case of sell, the user specifies min_limit of an asset_out which should be exchanged for a certain amount of asset_in."),(0,r.kt)("p",null,"buy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[pallet::weight(<T as Config>::WeightInfo::buy())]\npub fn buy(\n    origin: OriginFor<T>,\n    asset_out: AssetId,\n    asset_in: AssetId,\n    amount: Balance,\n    max_limit: Balance,\n    discount: bool,\n) -> DispatchResultWithPostInfo {\n    let who = ensure_signed(origin)?;\n\n    <Self as AMM<_, _, _, _>>::buy(&who, AssetPair { asset_in, asset_out }, amount, max_limit, discount)?;\n\n    Ok(().into())\n}\n")),(0,r.kt)("p",null,"In the case of buy, the user specifies max_limit of an asset_in to be exchanged for a certain amount of asset_out."),(0,r.kt)("p",null,"If you look at the implementation of the buy/sell functions, you will see that they make calls under the hood to the AMM trait implementation for this pallet. This helps with avoiding code duplication and making this pallet easily usable in an exchange."))}p.isMDXComponent=!0}}]);