(self.webpackChunkhydra_dx_docs=self.webpackChunkhydra_dx_docs||[]).push([[403],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return s},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,h=m["".concat(o,".").concat(d)]||m[d]||p[d]||l;return n?a.createElement(h,i(i({ref:t},s),{},{components:n})):a.createElement(h,i({ref:t},s))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6863:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return c},toc:function(){return o},default:function(){return s}});var a=n(2122),r=n(9756),l=(n(7294),n(3905)),i={id:"dev_math",title:"HydraDX Math Crate"},c={unversionedId:"dev_math",id:"dev_math",isDocsHomePage:!1,title:"HydraDX Math Crate",description:"Overview",source:"@site/docs/dev_math.md",sourceDirName:".",slug:"/dev_math",permalink:"/fr/dev_math",editUrl:"https://github.com/galacticcouncil/HydraDX-docs/edit/main/docs/dev_math.md",version:"current",frontMatter:{id:"dev_math",title:"HydraDX Math Crate"},sidebar:"sidebar",previous:{title:"Primitives Crate",permalink:"/fr/dev_primitives"},next:{title:"Intro",permalink:"/fr/dev_pallets"}},o=[{value:"Overview",id:"overview",children:[{value:"xyk",id:"xyk",children:[]},{value:"HDX",id:"hdx",children:[]}]}],u={toc:o};function s(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"overview"},"Overview"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://github.com/galacticcouncil/HydraDX-math"},"https://github.com/galacticcouncil/HydraDX-math")),(0,l.kt)("p",null,"The HydraDX math crate contains all the mathematical formulas for the various implementations of AMM pools."),(0,l.kt)("p",null,"The main goal of having this math functionality as a separate crate is to make it possible to easily compile it into WebAssembly which allows us to  use the wasm library directly on the frontend. "),(0,l.kt)("p",null,"This way, we can compute everything that is needed on the frontend side in the same way that it is calculated when a transaction is submitted using\nsame math and without the need to talk to the node."),(0,l.kt)("p",null,"Another benefit which domes from this approach - it is easily testable."),(0,l.kt)("h3",{id:"xyk"},"xyk"),(0,l.kt)("p",null,"XYK implementation can be found in amm.rs. It consists of following methods:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn calculate_spot_price(in_reserve: Balance, out_reserve: Balance, amount: Balance) -> Result<Balance, MathError> {}\npub fn calculate_out_given_in(in_reserve: Balance, out_reserve: Balance, amount_in: Balance) -> Result<Balance, MathError> {}\npub fn calculate_in_given_out(out_reserve: Balance, in_reserve: Balance, amount_out: Balance) -> Result<Balance, MathError> {}\npub fn calculate_liquidity_in(asset_a_reserve: Balance, asset_b_reserve: Balance, amount: Balance) -> Result<Balance, MathError> {}\npub fn calculate_liquidity_out(asset_a_reserve: Balance,\n    asset_b_reserve: Balance,\n    amount: Balance,\n    total_liquidity: Balance,\n) -> Result<(Balance, Balance), MathError> {}\n")),(0,l.kt)("h3",{id:"hdx"},"HDX"),(0,l.kt)("p",null,"The HydraDX Omnipool math implementation can be found in the hdx module."),(0,l.kt)("p",null,"It has similar methods as xyk but different parameters are needed."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn calculate_spot_price(\n    in_reserve: Balance,\n    out_reserve: Balance,\n    in_weight: Balance,\n    out_weight: Balance,\n    amount: Balance,\n) -> Result<Balance, MathError> {}\n\npub fn calculate_out_given_in(\n    in_reserve: Balance,\n    out_reserve: Balance,\n    in_weight: Balance,\n    out_weight: Balance,\n    amount: Balance,\n) -> Result<Balance, MathError> {}\n\npub fn calculate_in_given_out(\n    in_reserve: Balance,\n    out_reserve: Balance,\n    in_weight: Balance,\n    out_weight: Balance,\n    amount: Balance,\n) -> Result<Balance, MathError> {}\n\npub fn calculate_liquidity_in(\n    asset_reserve: Balance,\n    core_asset_reserve: Balance,\n    asset_weight: Balance,\n    core_asset_weight: Balance,\n    amount: Balance,\n) -> Result<Balance, MathError> {}\n\npub fn calculate_liquidity_out(\n    asset_reserve: Balance,\n    core_asset_reserve: Balance,\n    asset_weight: Balance,\n    core_asset_weight: Balance,\n    amount: Balance,\n) -> Result<(Balance, Balance), MathError> {}\n\n")))}s.isMDXComponent=!0}}]);